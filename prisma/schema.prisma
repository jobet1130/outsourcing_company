generator client {
  provider = "prisma-client-py"
  interface = "asyncio"
  recursive_type_depth = 5
  output = "../prisma_client"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  relationMode = "prisma"
}

/// ---------------------------
/// Models
/// ---------------------------

model User {
  id            Int             @id @default(autoincrement())
  email         String          @unique
  name          String?
  teamMembers   TeamMember[]
  password      String    @db.VarChar(255)
  role          String    @default("USER") // e.g., "ADMIN", "MANAGER", "STAFF"
  isActive      Boolean   @default(true)
  lastLogin     DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  company       Company?      @relation(fields: [companyId], references: [id])
  companyId     Int?          @map("company_id")

  blogPosts     BlogPost[]    @relation("BlogPostAuthor")
  jobApplications Application[] @relation("JobApplicationCandidate")

  @@index([companyId])
}

model Company {
  id              Int       @id @default(autoincrement())
  name            String    @unique
  description     String?
  address         String?
  city            String?
  country         String?
  postalCode      String?
  phone           String?
  email           String?   @unique
  website         String?
  taxId           String?   @unique
  registrationNo  String?   @unique
  isActive        Boolean   @default(true)
  logoUrl         String?
  industry        String?
  size            String?   // e.g., "SMALL", "MEDIUM", "LARGE"
  notes           String?   @db.Text
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  users           User[]
  services        Service[]
  teamMembers     TeamMember[]
  jobs            Job[]

  @@index([name])
  @@index([email])
  @@index([isActive])
}

model Service {
  id               Int       @id @default(autoincrement())
  name             String
  description      String?   @db.Text
  category         String?   // e.g., "IT", "HR", "Finance", "Marketing"
  price            Float     @default(0.0)
  priceUnit        String    @default("USD")  // e.g., "USD", "EUR", "PHP"
  priceType        String    @default("HOURLY")  // e.g., "HOURLY", "FIXED", "MONTHLY"
  duration         Int?      // Duration in minutes/hours/days based on priceType
  isActive         Boolean   @default(true)
  requiresApproval Boolean   @default(false)
  taxRate          Float?    @default(0.0)
  notes            String?   @db.Text
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  company          Company   @relation(fields: [companyId], references: [id])
  companyId        Int       @map("company_id")

  // (optional) jobs offered for this service
  jobs             Job[]     @relation("JobToService")

  @@index([name], map: "serviceNameIndex")
  @@index([category], map: "serviceCategoryIndex")
  @@index([isActive], map: "serviceIsActiveIndex")
  @@index([companyId], map: "serviceCompanyIdIndex")
  @@unique([name, companyId], name: "service_name_company")
}

model TeamMember {
  id              Int         @id @default(autoincrement())

  // Personal Information
  firstName       String
  middleName      String?
  lastName        String
  dateOfBirth     DateTime?
  gender          String?     // e.g., "MALE", "FEMALE", "OTHER", "PREFER_NOT_TO_SAY"
  personalEmail   String?     @unique
  workEmail       String?     @unique
  phoneNumber     String?
  address         String?
  city            String?
  country         String?
  postalCode      String?

  // Employment Details
  employeeId      String?     @unique
  position        String?
  department      String?
  hireDate        DateTime?
  terminationDate DateTime?
  employmentType  String?     // e.g., "FULL_TIME", "PART_TIME", "CONTRACT", "INTERN"
  status          String      @default("ACTIVE") // e.g., "ACTIVE", "ON_LEAVE", "TERMINATED"

  // Work Information
  bio             String?     @db.Text
  notes           String?     @db.Text

  // System
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  company         Company     @relation(fields: [companyId], references: [id])
  companyId       Int         @map("company_id")

  // Optional user account
  user            User?       @relation(fields: [userId], references: [id])
  userId          Int?        @map("user_id")

  // Skills
  skills          TeamMemberSkill[]

  @@index([firstName, lastName])
  @@index([employeeId])
  @@index([status])
  @@index([isActive])
  @@index([companyId])
  @@index([userId])
}

model TeamMemberSkill {
  id               Int         @id @default(autoincrement())
  name             String
  level            Int?        @default(3) // 1-5 scale
  yearsOfExperience Int?       // Years of experience
  isPrimary        Boolean     @default(false)

  // Relations
  teamMember       TeamMember  @relation(fields: [teamMemberId], references: [id])
  teamMemberId     Int

  @@index([name])
  @@index([teamMemberId])
  @@unique([name, teamMemberId], name: "skill_name_team_member")
}

model BlogCategory {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  slug        String    @unique
  description String?
  isActive    Boolean   @default(true)
  order       Int       @default(0)
  parentId    Int?
  parent      BlogCategory? @relation("CategoryToSubcategory", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children    BlogCategory[] @relation("CategoryToSubcategory")
  posts       BlogPost[]

  @@index([slug], map: "blogCategorySlugIndex")
  @@index([isActive], map: "blogCategoryIsActiveIndex")
  @@index([order], map: "blogCategoryOrderIndex")
  @@index([parentId], map: "blogCategoryParentIdIndex")
}

model BlogTag {
  id          Int             @id @default(autoincrement())
  name        String          @unique
  slug        String          @unique
  description String?
  postTags    BlogPostTag[]   @relation("BlogPostTags")  // Explicitly name the relation

  @@index([slug], map: "blog_tag_slug_idx")
  @@index([id], map: "blog_tag_id_idx")
}

model BlogPost {
  id            Int        @id @default(autoincrement())
  title         String
  slug          String     @unique
  excerpt       String?    @db.Text
  content       String     @db.Text
  featuredImage String?
  isPublished   Boolean    @default(false)
  publishedAt   DateTime?
  viewCount     Int        @default(0)
  seoTitle      String?
  seoDescription String?   @db.Text
  seoKeywords   String?

  // Relations
  author        User          @relation("BlogPostAuthor", fields: [authorId], references: [id])
  authorId      Int           @map("author_id")
  category      BlogCategory? @relation(fields: [categoryId], references: [id])
  categoryId    Int?          @map("category_id")
  comments      BlogComment[]
  postTags      BlogPostTag[] @relation("BlogPostTags")

  // System
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([slug], map: "blog_post_slug_idx")
  @@index([isPublished], map: "blog_post_is_published_idx")
  @@index([publishedAt], map: "blog_post_published_at_idx")
  @@index([authorId], map: "blog_post_author_id_idx")
  @@index([categoryId], map: "blog_post_category_id_idx")
}

model BlogComment {
  id         Int       @id @default(autoincrement())
  authorName String
  authorEmail String
  content     String    @db.Text
  isApproved  Boolean   @default(false)

  // Relations
  post       BlogPost   @relation(fields: [postId], references: [id])
  postId     Int        @map("post_id")
  parent     BlogComment? @relation("CommentToReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  parentId   Int?       @map("parent_id")
  replies    BlogComment[] @relation("CommentToReplies")

  // System
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([postId], map: "blogCommentPostIdIndex")
  @@index([parentId], map: "blogCommentParentIdIndex")
  @@index([isApproved], map: "blogCommentIsApprovedIndex")
}

/// Job Enums
enum JobType {
  FULL_TIME
  PART_TIME
  CONTRACT
  TEMPORARY
  INTERNSHIP
  FREELANCE
  REMOTE
  ONSITE
  HYBRID
}

enum JobStatus {
  DRAFT
  PUBLISHED
  CLOSED
  FILLED
  CANCELLED
}

enum ApplicationStatus {
  PENDING
  REVIEWED
  INTERVIEWING
  OFFER_MADE
  HIRED
  REJECTED
  WITHDRAWN
}

model Job {
  id                 Int         @id @default(autoincrement())
  title              String
  slug               String      @unique
  description        String      @db.Text
  requirements       String?     @db.Text
  responsibilities   String?     @db.Text
  benefits           String?     @db.Text
  location           String?
  jobType            JobType
  status             JobStatus   @default(DRAFT)
  isRemote           Boolean     @default(false)
  salaryMin          Float?
  salaryMax          Float?
  salaryCurrency     String?     @default("USD")
  salaryType         String?     @default("YEARLY")
  experienceLevel    String?
  applicationDeadline DateTime?

  // Relations
  company            Company     @relation(fields: [companyId], references: [id])
  companyId          Int
  applications       Application[]

  // (optional) link to service if job is for a specific service
  service            Service?    @relation("JobToService", fields: [serviceId], references: [id])
  serviceId          Int?        @map("service_id")

  // System
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt
  publishedAt        DateTime?

  @@index([slug], map: "jobSlugIndex")
  @@index([jobType], map: "jobTypeIndex")
  @@index([status], map: "jobStatusIndex")
  @@index([companyId], map: "jobCompanyIdIndex")
  @@index([serviceId], map: "jobServiceIdIndex")
  @@index([isRemote], map: "jobIsRemoteIndex")
  @@index([applicationDeadline], map: "jobApplicationDeadlineIndex")
}

// join table between BlogPost and BlogTag
model BlogPostTag {
  post      BlogPost @relation("BlogPostTags", fields: [postId], references: [id])
  postId    Int      @map("post_id")
  tag       BlogTag  @relation("BlogPostTags", fields: [tagId], references: [id])
  tagId     Int      @map("tag_id")
  
  @@id([postId, tagId])
  @@index([postId], name: "blog_post_tag_post_id_idx")
  @@index([tagId], name: "blog_post_tag_tag_id_idx")
}

model Application {
  id          Int               @id @default(autoincrement())
  coverLetter String?           @db.Text
  resumeUrl   String?
  status      ApplicationStatus @default(PENDING)
  notes       String?           @db.Text

  // Relations
  job         Job         @relation(fields: [jobId], references: [id])
  jobId       Int         @map("job_id")
  applicant   User        @relation("JobApplicationCandidate", fields: [applicantId], references: [id])
  applicantId Int         @map("applicant_id")

  // System
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@index([jobId])
  @@index([applicantId])
  @@index([status])
  @@unique([jobId, applicantId], name: "job_applicant_unique")
}
